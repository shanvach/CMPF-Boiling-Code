!!****if* source/Grid/GridMain/AMR/Amrex/gr_auxFluxData
!! NOTICE
!!  Copyright 2023 UChicago Argonne, LLC and contributors
!!
!!  Licensed under the Apache License, Version 2.0 (the "License");
!!  you may not use this file except in compliance with the License.
!!
!!  Unless required by applicable law or agreed to in writing, software
!!  distributed under the License is distributed on an "AS IS" BASIS,
!!  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!  See the License for the specific language governing permissions and
!!  limitations under the License.
!!
!! NAME
!!  gr_auxFluxData
!!
!! SYNOPSIS
!!
!!  use gr_auxFluxData
!!
!!  call gr_auxFluxInit()
!!  call gr_auxFluxFree()
!!
!! DESCRIPTION
!!
!!  This module holds some auxiliary arrays that store fluxes.
!!
!!  The arrays here, together with FlashFluxRegisters provided by
!!  AMReX, implement the SPFS (semi-permanent flux storage) in the
!!  case of the GridMain/AMR/Amrex Grid implementation with no
!!  level-wide fluxes.
!!
!!  The number of fluxes that can be stored per cell face is determined by
!!  the preprocessor symbol NFLUXES, which is defined in the header file
!!  Simulation.h generated by setup.
!!
!!  The capability of this auxiliary flux storage depends on certain
!!  preprocessor macros. Currently,
!!     * Storage is provided for all cells that sit at a block boundary
!!       (inside, NOT guard cells).
!!     * For each such cell, there is space for fluxes at the cell face
!!       that lies on the block face.
!!     * For each such cell, there is also space for fluxes at the cell
!!       face opposite.
!!     * if GRID_SPFS_CAP3 is defined, there is also space for the
!!       remaining faces fo such cells. In that case, this auxiliary flux
!!       storage can be used, e.g., by a Hydro algorithm, to completely
!!       defer updating of the solution in the volumes of such boundary
!!       cells from the point when the fluxes are first computed to a later
!!       point, say after fine-to-coarse flux communciation has happened,
!!       without the need to keep copies of those fluxes around elsewhere.
!!
!!  This storage can be used to hold proper fluxes or flux densities,
!!  depending on the needs of callers, or even something else entirely that
!!  is associated with cell faces.
!!
!!  Currently this storage is used as part of the SPFS by the Amrex Grid
!!  implementation. It can be used there to store flux data for a subset of
!!  Grid blocks, limited to LEAF blocks and possibly limited further by
!!  excluding blocks by levels and by other criteria.
!!
!! SEE ALSO
!!
!!  Grid_putFluxData_block
!!  Grid_getFluxCorrData_block
!!  gr_leafBlockInfo.F90
!!
!! HISTORY
!!  2023-10-28 K. Weide  Created from parts of ../Paramesh4/gr_specificData etc.
!!
!!
!!***

! The arrays defined below are written in the customary Flash-X index order:
! variable (or flux number) index first, followed by spatial indices.
! Therefore index ordering will be necessary to make them agree with the order
! required in Amrex-specific code.

!!REORDER(5): gr_tflux[XYZ]
!!REORDER(5): gr_[xyz]flx
!!REORDER(5): gr_xflx_[yz]face, gr_yflx_[xz]face, gr_zflx_[xy]face

Module gr_auxFluxData

  implicit none

#include "constants.h"
#include "Simulation.h"

  integer, parameter :: gr_iloFl = GRID_ILO   ! -2  for staggered mesh MHD
  integer, parameter :: gr_ihiFl = GRID_IHI   ! +2  for staggered mesh MHD
  integer, parameter :: gr_jloFl = GRID_JLO   ! -2*K2D  for staggered mesh MHD
  integer, parameter :: gr_jhiFl = GRID_JHI   ! +2*K2D  for staggered mesh MHD
  integer, parameter :: gr_kloFl = GRID_KLO   ! -2*K3D  for staggered mesh MHD
  integer, parameter :: gr_khiFl = GRID_KHI   ! +2*K3D  for staggered mesh MHD

  integer, parameter, dimension(3) :: gr_loFl = (/gr_iloFl,gr_jloFl,gr_kloFl/)


#ifdef BSS_GRID_ARRAYS
  ! This first variant declares the aux flux storage as constant size
  ! arrays.

  !Arrays gr_tflux[XYZ] store fluxes for cell faces that coincide with
  !block faces. This storage may duplicate what is also stored in the part
  !of the SPFS (semipermanent flux storage) that is natively implemented in
  !the unterlying mesh implementation - (Flash)FluxRegisters in the case of
  !the AMReX mesh.
  !This duplicate storage is useful because, in contrast to storage that
  !belongs to the underlying mesh, it is not affected by the communication
  !and replacement. Also, perhaps more importantly, the underlying mesh
  !implementation may not actually store fluxes for all outer cell faces,
  !but only, say, for finer cell faces at refinement boundaries; and/or the
  !underyying mesh implementation may not actually provide a way to retrieve
  !cell fluxes in the original form, once they have been stored.
  !Tee considerations of the last sentence apply to AMReX.
  real,save, dimension(NFLUXES,2,NYB,NZB,MAXBLOCKS) :: gr_tfluxX
  real,save, dimension(NFLUXES,NXB,2,NZB,MAXBLOCKS) :: gr_tfluxY
  real,save, dimension(NFLUXES,NXB,NYB,2,MAXBLOCKS) :: gr_tfluxZ

  !Arrays gr_[xyz]flx store fluxes for cell faces that are parallel to a
  !near block face, but do not lie on the block face. In other words,
  !inward-pointing faces, on the opposite side of the cell to the
  !gr_tflux[XYZ] locations. 
  !These fluxes are not memorized by FlashFluxRegisters at all.
  real,save, dimension(NFLUXES,2,NYB,NZB,MAXBLOCKS) :: gr_xflx
  real,save, dimension(NFLUXES,NXB,2,NZB,MAXBLOCKS) :: gr_yflx
  real,save, dimension(NFLUXES,NXB,NYB,2,MAXBLOCKS) :: gr_zflx

  !The below are for storing fluxes, for one layer of (inner) cells, located
  !at the remaining faces, i.e., those faces not facing the same way as the
  !block boundary.
# ifdef GRID_SPFS_CAP3
#  if NDIM >= 2
  real,save, dimension(NFLUXES,2:NXB, 2   ,NZB  ,MAXBLOCKS) :: gr_xflx_yface
  real,save, dimension(NFLUXES,2    ,2:NYB,NZB  ,MAXBLOCKS) :: gr_yflx_xface
#   if NDIM == 3
  real,save, dimension(NFLUXES,2:NXB,NYB  , 2   ,MAXBLOCKS) :: gr_xflx_zface
  real,save, dimension(NFLUXES,NXB,  2:NYB, 2   ,MAXBLOCKS) :: gr_yflx_zface
  real,save, dimension(NFLUXES, 2 ,NYB    ,2:NZB,MAXBLOCKS) :: gr_zflx_xface
  real,save, dimension(NFLUXES,NXB, 2     ,2:NZB,MAXBLOCKS) :: gr_zflx_yface
#   endif
#  endif
# endif
#else
  ! This first variant declares the aux flux storage as allocatable arrays.
  ! See above for more explanantion
  real, save, allocatable :: gr_tfluxX(:,:,:,:,:)
  real, save, allocatable :: gr_tfluxY(:,:,:,:,:)
  real, save, allocatable :: gr_tfluxZ(:,:,:,:,:)

  real, save, allocatable :: gr_xflx(:,:,:,:,:)
  real, save, allocatable :: gr_yflx(:,:,:,:,:)
  real, save, allocatable :: gr_zflx(:,:,:,:,:)

  !For unsplit hydro/MHD to store transverse fluxes on AMR
# ifdef GRID_SPFS_CAP3
#  if NDIM >= 2
  real,save, allocatable :: gr_xflx_yface(:,:,:,:,:)
  real,save, allocatable :: gr_yflx_xface(:,:,:,:,:)
#   if NDIM == 3
  real,save, allocatable :: gr_xflx_zface(:,:,:,:,:)
  real,save, allocatable :: gr_yflx_zface(:,:,:,:,:)
  real,save, allocatable :: gr_zflx_xface(:,:,:,:,:)
  real,save, allocatable :: gr_zflx_yface(:,:,:,:,:)
#   endif
#  endif
# endif
#endif

contains
  subroutine gr_auxFluxInit()
    implicit none

    ! Allocate those arrays when needed
#ifndef BSS_GRID_ARRAYS
    allocate(gr_xflx(NFLUXES,2,NYB,NZB,MAXBLOCKS))
    allocate(gr_yflx(NFLUXES,NXB,2,NZB,MAXBLOCKS))
    allocate(gr_zflx(NFLUXES,NXB,NYB,2,MAXBLOCKS))

    allocate(gr_tfluxX(NFLUXES,2,NYB,NZB,MAXBLOCKS))
    allocate(gr_tfluxY(NFLUXES,NXB,2,NZB,MAXBLOCKS))
    allocate(gr_tfluxZ(NFLUXES,NXB,NYB,2,MAXBLOCKS))

# ifdef GRID_SPFS_CAP3
#  if NDIM >= 2
    allocate(gr_xflx_yface(NFLUXES,3:NXB-1, 2     ,NZB  ,MAXBLOCKS))
    allocate(gr_yflx_xface(NFLUXES,2      ,3:NYB-1,NZB  ,MAXBLOCKS))
#   if NDIM == 3
    allocate(gr_xflx_zface(NFLUXES,3:NXB-1,2:NYB-1, 2     ,MAXBLOCKS))
    allocate(gr_yflx_zface(NFLUXES,2:NXB-1,3:NYB-1, 2     ,MAXBLOCKS))
    allocate(gr_zflx_xface(NFLUXES, 2     ,NYB    ,3:NZB-1,MAXBLOCKS))
    allocate(gr_zflx_yface(NFLUXES,2:NXB-1, 2     ,3:NZB-1,MAXBLOCKS))
#   endif
#  endif
# endif

#endif

    ! There isn't actually a routine for initializing (zeroing) the memory of
    ! these arrays. That shouldn't be necessary, if they are used responsibly!
  end subroutine gr_auxFluxInit

  subroutine gr_auxFluxFree()
    implicit none

    ! Dellocate those arrays when allocated
#ifndef BSS_GRID_ARRAYS
    deallocate(gr_xflx)
    deallocate(gr_yflx)
    deallocate(gr_zflx)

    deallocate(gr_tfluxX)
    deallocate(gr_tfluxY)
    deallocate(gr_tfluxZ)

# ifdef GRID_SPFS_CAP3
#  if NDIM >= 2
    deallocate(gr_xflx_yface)
    deallocate(gr_yflx_xface)
#   if NDIM == 3
    deallocate(gr_xflx_zface)
    deallocate(gr_yflx_zface)
    deallocate(gr_zflx_xface)
    deallocate(gr_zflx_yface)
#   endif
#  endif
# endif

#endif
  end subroutine gr_auxFluxFree
end Module gr_auxFluxData
! Local Variables:
! f90-program-indent: 2
! indent-tabs-mode: nil
! End:
