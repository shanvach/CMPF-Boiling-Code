!!****if* source/physics/Hydro/HydroMain/unsplit/hy_unsplitUpdate
!! NOTICE
!!  Copyright 2022 UChicago Argonne, LLC and contributors
!!
!!  Licensed under the Apache License, Version 2.0 (the "License");
!!  you may not use this file except in compliance with the License.
!!
!!  Unless required by applicable law or agreed to in writing, software
!!  distributed under the License is distributed on an "AS IS" BASIS,
!!  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!  See the License for the specific language governing permissions and
!!  limitations under the License.
!!
!! NAME
!!
!!  hy_unsplitUpdate
!!
!! SYNOPSIS
!!
!!  call hy_unsplitUpdate( integer(IN) :: blockID,
!!                        integer(IN) :: rangeSwitch,
!!                        real(IN)    :: dt,
!!                        real(IN)    :: del(MDM),
!!                        integer(IN) :: blkLimits(2,MDIM),
!!                        integer(IN) :: blkLimitsGC(2,MDIM),
!!                        real(IN)    :: xflux(:,:,:,:), 
!!                        real(IN)    :: yflux(:,:,:,:), 
!!                        real(IN)    :: zflux(:,:,:,:),
!!                        real(IN)    :: gravX(:,:,:),
!!                        real(IN)    :: gravY(:,:,:),
!!                        real(IN)    :: gravZ(:,:,:),
!!                        real,POINTER, dimension(:,:,:,:) :: scrch_Ptr)
!!
!! ARGUMENTS
!!
!!   blockID      - current block ID
!!   rangeSwitch  - switch for selective updates on AMR (only valid for hydro and not for MHD).
!!                  One of the following values (defined in UHD.h)
!!                    UPDATE_ALL,              update all variables in all cells.
!!                    UPDATE_INTERIOR,         update all variables in interior cells.
!!                    UPDATE_BOUND,            update all variables in boundary cells.
!!                    UPDATE_SPECMS_INTERIOR,  update species and mass scalar variables in interior cells;
!!                                             values of those variables in those cells
!!                                             will be left in multiplied-by-density form.
!!                    UPDATE_ALL_SPECMSBOUND,  update non-species / non-mass-scalar variables in all
!!                                             cells; update species and mass scalar variables in
!!                                             boundary cells; and finish updating of species and mass
!!                                             scalar variables in interior cells,
!!                                             by dividing those values by the updated density.
!!                  Boundary cells here are cells that have at least one face at a block boundary;
!!                  interior cells are the remaining cells of a block.
!!                  Note that neither boundary cells nor interior cells, in the sense used here,
!!                  are guard cells! Guard cells should not be modified by this routine.
!!   dt           - timestep
!!   del          - coordinate spacings in {X,Y,Z} directions
!!   blkLimits    - an array that holds the lower and upper indices of the section
!!                  of block without the guard cells
!!   blkLimitsGC    - an array that holds the lower and upper indices of the section
!!                  of block with the guard cells
!!   xflux,yflux,zflux - cell face centered fluxes at each {=X,Y,Z} direction
!!   gravX,gravY,gravZ - gravitational acceleration components in X,Y,Z directions
!!   scrch_Ptr      - pointer to scratch space; used both for receiving some data, and
!!                    for storing some data for later processing in the FLASH_UHD_3T case.
!!
!! DESCRIPTION
!!
!!   This routine updates the cell-centered conservative variables and intermediate
!!   internal energy to the next time step using fluxes for all spatial directions (unsplit scheme).
!!
!! NOTES
!!
!!   The ENER_VAR and EINT_VAR components of UNK are now always kept in specific
!!   (i.e., energy per mass) form, on entry as well as on return from this routine.
!!   This is changed from the behavior in FLASH4.2.2 and earlier.
!!***

!!REORDER(4): Uin, Uout, Uold, SpOld, scrch_Ptr, [xyz]flux

#include "constants.h"
#include "Simulation.h"
#include "Eos.h"
#include "UHD.h"

  Subroutine hy_unsplitUpdate(tileDesc,Uin,Uout,rangeSwitch,dt,del,blkLimits,&
                                  blGC,loFl,xflux,yflux,zflux,gravX,gravY,gravZ,&
                                  scrch_Ptr)

    use Grid_tile,            ONLY : Grid_tile_t
    use Hydro_data,           ONLY : hy_smalldens,hy_order,hy_irenorm,hy_numXN, &
                                     hy_meshMe, &
                                     hy_geometry, hy_gcMaskSize, &
                                     hy_gcMask, hy_eswitch, hy_useAuxEintEqn, &
                                     hy_fullSpecMsFluxHandling, &
                                     hy_conserveAngMom, hy_smallE, hy_irenorm
    use Hydro_data,           ONLY : fP => hy_fPresInMomFlux
#ifdef FLASH_USM_MHD
  use Hydro_data,             ONLY : hy_mref, hy_hallVelocity, &
                                     hy_useMagneticResistivity, hy_conserveAngField
  use MagneticResistivity_interface, &
                              ONLY : MagneticResistivity
  use hy_interface,       ONLY : hy_addOhmicHeating 
#endif
#if defined(FLASH_USM_MHD) || defined(FLASH_UGLM_MHD) 
    use Hydro_data,           ONLY : hy_forceHydroLimit
#endif
    use hy_interface,     ONLY : hy_updateSpeciesMassScalar
#ifdef FLASH_UHD_3T
#ifdef FLASH_USM_MHD
  use hy_interface,       ONLY : hy_getCurrents
#endif
#endif
    use Driver_interface,     ONLY : Driver_abort
    use Grid_interface,       ONLY : Grid_getCellCoords, &
                                     Grid_getCellFaceAreas, &
                                     Grid_getCellVolumes, &
                                     Grid_renormAbundance, &
                                     Grid_limitAbundance
#ifdef FLASH_UHD_3T
#ifdef FLASH_USM_MHD
    use Eos_interface,        ONLY : Eos_getAbarZbar
#endif
#endif

    implicit none

    !! ---- Arguments ---------------------------------
    type(Grid_tile_t), intent(IN) :: tileDesc
    integer,intent(IN) :: rangeSwitch
    real, intent(IN)   :: dt
    real, intent(IN)   :: del(MDIM)
    integer,intent(IN) :: blkLimits(LOW:HIGH,MDIM)
    integer,intent(IN) :: blGC(LOW:HIGH,MDIM)
    integer, dimension(MDIM+1),intent(IN)        :: loFl
    real, intent(IN) :: XFLUX (loFl(1):, loFl(2): ,loFl(3):, loFl(4): )!CAPITALIZED TO PREVENT INDEX REORDERING!
    real, intent(IN) :: YFLUX (loFl(1):, loFl(2): ,loFl(3):, loFl(4): )!CAPITALIZATION INTENTIONAL!
    real, intent(IN) :: ZFLUX (loFl(1):, loFl(2): ,loFl(3):, loFl(4): )!CAPITALIZATION INTENTIONAL!
    real, dimension(blGC(LOW,IAXIS):blGC(HIGH,IAXIS),blGC(LOW,JAXIS):blGC(HIGH,JAXIS),blGC(LOW,KAXIS):blGC(HIGH,KAXIS)),& 
         intent(IN) :: gravX,gravY,gravZ
    real, pointer, dimension(:,:,:,:) :: Uin, Uout, scrch_Ptr

    !!---------------------------------------------------

    integer :: i,j,k,imin,imax,jmin,jmax,kmin,kmax
    integer :: ifirst,ibMin,ibMax,jbMin,jbMax,kbMin,kbMax
    real    :: dx, dy, dz, dx_sph
    real    :: dxv, dyv
    real, dimension(HY_VARINUM) :: U0
    real, dimension(NFLUXES)    :: FL,FR,GL,GR,HL,HR
    real    :: densNew, densNph ! densNph: "dens at n+1/2"
    real    :: IntEner,tempPres

#if (NSPECIES+NMASS_SCALARS) > 0
    real, dimension(hy_numXN,blGC(LOW,IAXIS):blGC(HIGH,IAXIS),blGC(LOW,JAXIS):blGC(HIGH,JAXIS),blGC(LOW,KAXIS):blGC(HIGH,KAXIS)) :: SpOld
    real, dimension(6,blGC(LOW,IAXIS):blGC(HIGH,IAXIS),blGC(LOW,JAXIS):blGC(HIGH,JAXIS),blGC(LOW,KAXIS):blGC(HIGH,KAXIS)) :: Uold
#else
  !This is just here so I can have the same omp parallel directive whether
  !(NSPECIES+NMASS_SCALARS) > 0 or not.  SpOld and UOld are not used.
  real, dimension(1,1,1,1) :: SpOld
  real, dimension(1,1,1,1) :: UOld
#endif

    real, dimension(blGC(LOW,IAXIS):blGC(HIGH,IAXIS)) :: xCenter, xLeft, xRight
#if NDIM >= 2
    real, dimension(blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS)) :: yCenter
#else
    real, dimension(0) :: yCenter
#endif

    logical :: gcMask(hy_gcMaskSize)
    real, dimension(HY_VARINUM) :: Sgeo, Sphys
    real, dimension(blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS)+1,&
                    blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS),  &
                    blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS) ) :: faceAreas
#if NDIM > 1
    real, dimension(blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS)  ,&
                    blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS)+1,&
                    blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS) ) :: faceAreasY
#endif
    real, dimension(blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS),&
                    blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS),  &
                    blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS) ) :: cellVolumes

#if defined(FLASH_USM_MHD) && defined(FLASH_UHD_3T) 
    real, dimension(3, blGC(LOW,IAXIS):blGC(HIGH,IAXIS),blGC(LOW,JAXIS):blGC(HIGH,JAXIS),blGC(LOW,KAXIS):blGC(HIGH,KAXIS)) :: Jp, Jm
#else
    real    :: Jp, Jm
#endif
    integer,parameter :: ky=K2D,kz=K3D
    integer :: iskip
    real    :: temp, hdt
    real    :: presStar, densStar, pmomStar, tmomStar, xmomStar
    real    :: pmagStar, xmagStar, zmagStar
    real    :: xvel0, phiVel0, thtVel0
    integer :: VEL_PHI, MOM_PHI, MOM_PHI_FLUX, MAG_PHI,  MAG_PHI_FLUX
    integer :: VEL_ZI, MOM_ZI, MOM_ZI_FLUX, MAG_ZI,  MAG_ZI_FLUX
    integer :: VEL_THT, MOM_THT, MOM_THT_FLUX, velPhiVar
    real    :: leftFac, rghtFac, dPdr, rvol, alpha, cs, eta
    real    :: ekin, eint, newEint
    real    :: abar, zbar
    real    :: Qohm
#if (NSPECIES+NMASS_SCALARS) > 0
    integer :: isph,ispu
    real    :: sumSpecies
    real    :: newDens
    logical :: specialForInterior
#endif
  !! Resistive MHD 
  real, dimension(blGC(LOW,IAXIS):blGC(HIGH,IAXIS), & 
                  blGC(LOW,JAXIS):blGC(HIGH,JAXIS), & 
                  blGC(LOW,KAXIS):blGC(HIGH,KAXIS)) :: res_eta

  real, dimension(blGC(LOW,IAXIS):blGC(HIGH,IAXIS), & 
                  blGC(LOW,JAXIS):blGC(HIGH,JAXIS), & 
                  blGC(LOW,KAXIS):blGC(HIGH,KAXIS)) :: res_source                

  real    :: eta_loc, Jyp, Jym, dxBzm,dxBzp, inv_dVrm, inv_dVrp
  real, pointer,dimension(:)    :: speciesArr
#ifdef FLASH_USM_MHD
  res_eta = 0.0
#endif


    hdt = 0.5*dt

    if (rangeSwitch .NE. UPDATE_ALL) then
       ibMin = tileDesc%blkLimitsGC(LOW ,IAXIS)+NGUARD
       ibMax = tileDesc%blkLimitsGC(HIGH,IAXIS)-NGUARD
       jbMin = tileDesc%blkLimitsGC(LOW ,JAXIS)+NGUARD*ky
       jbMax = tileDesc%blkLimitsGC(HIGH,JAXIS)-NGUARD*ky
       kbMin = tileDesc%blkLimitsGC(LOW ,KAXIS)+NGUARD*kz
       kbMax = tileDesc%blkLimitsGC(HIGH,KAXIS)-NGUARD*kz
    end if

    if (rangeSwitch==UPDATE_SPECMS_INTERIOR) then
       call unsplitUpdateSpecMs
       return                   ! We are already done, RETURN now.
    end if

    Jp = 0.0 
    Jm = 0.0

    !! Set ranges for update
    imin  = blkLimits(LOW, IAXIS)
    imax  = blkLimits(HIGH,IAXIS)
    jmin  = 1
    jmax  = 1
    kmin  = 1
    kmax  = 1

    dx = del(DIR_X)
    dy = 1.
    dz = 1.
    if (NDIM >= 2) then
       jmin  = blkLimits(LOW, JAXIS)
       jmax  = blkLimits(HIGH,JAXIS)
       dy = del(DIR_Y)
       if (NDIM == 3) then
          kmin  = blkLimits(LOW, KAXIS)
          kmax  = blkLimits(HIGH,KAXIS)
          dz = del(DIR_Z)
       endif
    endif
    dxv = dx

    !! Set regions to update depending on update mode
    iskip = 1
    if (rangeSwitch==UPDATE_INTERIOR) then
       imin  = max(imin,ibMin+1)
       imax  = min(imax,ibMax-1)
       !iskip = 1
       if (NDIM >= 2) then
          jmin  = max(jmin,jbMin+1)
          jmax  = min(jmax,jbMax-1)
          if (NDIM == 3) then
             kmin  = max(kmin,kbMin+1)
             kmax  = min(kmax,kbMax-1)
          endif
       endif
    endif


    if (hy_geometry /= CARTESIAN) then
       call Grid_getCellFaceAreas(IAXIS, tileDesc%level, &
                                  lbound(faceAreas), ubound(faceAreas), &
                                  faceAreas)
#if NDIM > 1
       if (hy_geometry == SPHERICAL) then
          call Grid_getCellFaceAreas(JAXIS, tileDesc%level, &
                                     lbound(faceAreasY), ubound(faceAreasY), &
                                     faceAreasY)
       end if
#endif
       call Grid_getCellVolumes(tileDesc%level, &
                                lbound(cellVolumes), ubound(cellVolumes), &
                                cellVolumes)
    endif
 
!!$#if defined(FLASH_USM_MHD) || defined(FLASH_UGLM_MHD)
!!$    if (hy_forceHydroLimit) then
!!$       Uin(MAGX_VAR:MAGZ_VAR,:,:,:) = 0.
!!$    endif
!!$#endif


#if (NSPECIES+NMASS_SCALARS) > 0
    ! Use do loop nest to only set the portion of the tile
    ! that we are working on.
!!    call Driver_abort("[hy_unsplitUpdate] Update this to work with tiles")
    do ispu =  SPECIES_BEGIN, MASS_SCALARS_END
       isph= ispu-NPROP_VARS
       SpOld(isph, blGC(LOW,IAXIS):blGC(HIGH,IAXIS),&
             blGC(LOW,JAXIS):blGC(HIGH,JAXIS),&
             blGC(LOW,KAXIS):blGC(HIGH,KAXIS)) = Uin(ispu,&
             blGC(LOW,IAXIS):blGC(HIGH,IAXIS),&
             blGC(LOW,JAXIS):blGC(HIGH,JAXIS),&
             blGC(LOW,KAXIS):blGC(HIGH,KAXIS))
    enddo
    Uold(1,  blGC(LOW,IAXIS):blGC(HIGH,IAXIS),&
             blGC(LOW,JAXIS):blGC(HIGH,JAXIS),&
             blGC(LOW,KAXIS):blGC(HIGH,KAXIS)) = Uin(DENS_VAR,&
             blGC(LOW,IAXIS):blGC(HIGH,IAXIS),&
             blGC(LOW,JAXIS):blGC(HIGH,JAXIS),&
             blGC(LOW,KAXIS):blGC(HIGH,KAXIS))
    Uold(2,  blGC(LOW,IAXIS):blGC(HIGH,IAXIS),&
             blGC(LOW,JAXIS):blGC(HIGH,JAXIS),&
             blGC(LOW,KAXIS):blGC(HIGH,KAXIS)) = Uin(PRES_VAR,&
             blGC(LOW,IAXIS):blGC(HIGH,IAXIS),&
             blGC(LOW,JAXIS):blGC(HIGH,JAXIS),&
             blGC(LOW,KAXIS):blGC(HIGH,KAXIS))    
    Uold(3:5,blGC(LOW,IAXIS):blGC(HIGH,IAXIS),&
             blGC(LOW,JAXIS):blGC(HIGH,JAXIS),&
             blGC(LOW,KAXIS):blGC(HIGH,KAXIS)) = Uin(VELX_VAR:VELZ_VAR,&
             blGC(LOW,IAXIS):blGC(HIGH,IAXIS),&
             blGC(LOW,JAXIS):blGC(HIGH,JAXIS),&
             blGC(LOW,KAXIS):blGC(HIGH,KAXIS))
    Uold(6,  blGC(LOW,IAXIS):blGC(HIGH,IAXIS),&
             blGC(LOW,JAXIS):blGC(HIGH,JAXIS),&
             blGC(LOW,KAXIS):blGC(HIGH,KAXIS)) = Uin(GAME_VAR,&
             blGC(LOW,IAXIS):blGC(HIGH,IAXIS),&
             blGC(LOW,JAXIS):blGC(HIGH,JAXIS),&
             blGC(LOW,KAXIS):blGC(HIGH,KAXIS))

#endif

#ifdef DEBUG_HYDRO_POSITIVITY
    call Driver_abort("[hy_unsplitUpdate] This has not been tested")
    call Grid_getCellCoords(IAXIS, CENTER, tileDesc%level, &
                            blGC(LOW, :), blGC(HIGH, :), xCenter)
#else
    if (hy_geometry /= CARTESIAN) then
       call Grid_getCellCoords(IAXIS, CENTER, tileDesc%level, &
                               blGC(LOW, :), blGC(HIGH, :), xCenter)
    end if
#endif
    if (hy_geometry /= CARTESIAN) then
       call Grid_getCellCoords(IAXIS, LEFT_EDGE, tileDesc%level, &
                               blGC(LOW, :), blGC(HIGH, :), xLeft)
       call Grid_getCellCoords(IAXIS, RIGHT_EDGE, tileDesc%level, &
                               blGC(LOW, :), blGC(HIGH, :), xRight)
       if (NDIM >= 2 .AND. hy_geometry == SPHERICAL) then
          if (NDIM == 3) call Driver_abort("[hy_unsplitUpdate] This has not been tested")
          call Grid_getCellCoords(JAXIS, CENTER, tileDesc%level, &
                                  blkLimits(LOW, :), blkLimits(HIGH, :), &
                                  yCenter)
       end if
    endif
!!$
!!$#ifdef FLASH_USM_MHD
!!$#ifdef FLASH_UHD_3T
!!$    !! STORE THE OLD FIELD FOR CURRENT CALCULATION FOR 3T UPDATE
!!$    scrch_Ptr(HY_XN01_SCRATCHCTR_VAR,blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS), &
!!$            blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS), &
!!$            blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS)) = Uin(MAGX_VAR,blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS), &
!!$            blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS), &
!!$            blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS))
!!$    scrch_Ptr(HY_XN02_SCRATCHCTR_VAR,blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS), &
!!$            blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS), &
!!$            blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS)) = Uin(MAGY_VAR,blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS), &
!!$            blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS), &
!!$            blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS))
!!$    scrch_Ptr(HY_XN03_SCRATCHCTR_VAR,blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS), &
!!$            blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS), &
!!$            blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS)) = Uin(MAGZ_VAR,blkLimits(LOW,IAXIS):blkLimits(HIGH,IAXIS), &
!!$            blkLimits(LOW,JAXIS):blkLimits(HIGH,JAXIS), &
!!$            blkLimits(LOW,KAXIS):blkLimits(HIGH,KAXIS))
!!$#endif
!!$#endif


!!$    iskip = 1
!!$    if (NDIM == 1 .and. rangeSwitch .eq. UPDATE_BOUND) iskip = imax-imin
!!$    !! Loop to get magnetic resistivity source correction 
!!$#ifdef FLASH_USM_MHD
!!$    if (hy_geometry == CYLINDRICAL .and. hy_useMagneticResistivity) then
!!$       do k=kmin,kmax
!!$          do j=jmin-2,jmax+2
!!$             if (NDIM >= 2) then
!!$                iskip = 1
!!$                if (rangeSwitch == UPDATE_BOUND .and. j > jmin .and. j < jmax) then
!!$                   iskip = imax-imin
!!$                   if (NDIM == 3) then
!!$                      iskip = 1
!!$                      if (k > kmin .and. k < kmax) then
!!$                         iskip = imax-imin
!!$                      endif
!!$                   endif
!!$                endif
!!$             endif
!!$
!!$             do i=imin-2,imax+2,iskip
!!$                !! Get magnetic Resistivity
!!$                call MagneticResistivity(Uin(:,i-1,j,k),res_eta(i-1,j,k))
!!$                call MagneticResistivity(Uin(:,i,j,k),res_eta(i,j,k))
!!$                call MagneticResistivity(Uin(:,i+1,j,k),res_eta(i+1,j,k))                  
!!$
!!$                !! Normalize if needed
!!$                res_eta(i-1,j,k)  = res_eta(i-1,j,k)/hy_mref
!!$                res_eta(i  ,j,k)  = res_eta(i  ,j,k)/hy_mref
!!$                res_eta(i+1,j,k)  = res_eta(i+1,j,k)/hy_mref
!!$
!!$                !! We are adding the d (eta Jz)/dr as a source
!!$                !! term so as to keep the induction of Bphi with the source
!!$                !! formulation as it does not balance without....
!!$                eta_loc = 0.5*(res_eta(i,j,k)+res_eta(i-1,j,k))
!!$                inv_dVrm = xCenter(i)*abs(xCenter(i)) - xCenter(i-1)*abs(xCenter(i-1))
!!$                inv_dVrm = 2.0/inv_dVrm
!!$
!!$                dxBzm = (Uin(MAGZ_VAR,i  ,j,k)*xCenter(i) &
!!$                     -  Uin(MAGZ_VAR,i-1,j,k)*abs(xCenter(i-1)))*inv_dVrm
!!$                Jym = - eta_loc*dxBzm
!!$
!!$                eta_loc = 0.5*(res_eta(i,j,k)+res_eta(i+1,j,k))
!!$                inv_dVrp = xCenter(i+1)*abs(xCenter(i+1)) - xCenter(i)*abs(xCenter(i))
!!$                inv_dVrp = 2.0/inv_dVrp
!!$
!!$                dxBzp = (Uin(MAGZ_VAR,i+1,j,k)*xCenter(i+1) &
!!$                     -  Uin(MAGZ_VAR,i,j,k)*abs(xCenter(i)))*inv_dVrp                 
!!$                Jyp = - eta_loc*dxBzp
!!$
!!$                res_source(i,j,k) = -(Jyp-Jym)/dx
!!$             enddo !end of i loop
!!$          enddo !end of j loop
!!$       enddo !end of k loop
!!$    endif
!!$#endif

    ifirst = imin
    iskip = 1
    if (NDIM == 1 .and. rangeSwitch .eq. UPDATE_BOUND) then
       if (imin > ibMin) ifirst = ibMax
       iskip = max(ibMax - ibMin, 1)
    end if
    do k=kmin,kmax
       do j=jmin,jmax
          if (NDIM >= 2) then
             ifirst = imin
             iskip = 1
             if (rangeSwitch == UPDATE_BOUND .and. j > jbMin .and. j < jbMax) then
                if (imin > ibMin) ifirst = ibMax
                iskip = max(ibMax - ibMin, 1)
                if (NDIM == 3) then
                   ifirst = imin
                   iskip = 1
                   if (k > kbMin .and. k < kbMax) then
                      if (imin > ibMin) ifirst = ibMax
                      iskip = max(ibMax - ibMin, 1)
                   endif
                endif
             endif
          endif
          do i=ifirst,imax,iskip
#ifdef BDRY_VAR
             if (Uin(BDRY_VAR,i,j,k) .LE. 0.0) then
#endif
                !! For non-cartesian geometries
                leftFac = 1.
                rghtFac = 1.

                !! Fluxes at each local cell 
                FL(HY_DENS_FLUX:HY_VOLU_FLUX) = xflux(HY_DENS_FLUX:HY_VOLU_FLUX,i,  j,   k   )
                FR(HY_DENS_FLUX:HY_VOLU_FLUX) = xflux(HY_DENS_FLUX:HY_VOLU_FLUX,i+1,j,   k   )
                if (NDIM .GE. 2) then
                   GL(HY_DENS_FLUX:HY_VOLU_FLUX) = yflux(HY_DENS_FLUX:HY_VOLU_FLUX,i,  j,   k   )*ky
                   GR(HY_DENS_FLUX:HY_VOLU_FLUX) = yflux(HY_DENS_FLUX:HY_VOLU_FLUX,i,  j+ky,k   )*ky
                else
                   GL(:) = 0.0; GR(:) = 0.0
                end if
                if (NDIM == 3) then
                   HL(HY_DENS_FLUX:HY_VOLU_FLUX) = zflux(HY_DENS_FLUX:HY_VOLU_FLUX,i,  j,   k   )*kz
                   HR(HY_DENS_FLUX:HY_VOLU_FLUX) = zflux(HY_DENS_FLUX:HY_VOLU_FLUX,i,  j,   k+kz)*kz
                else
                   HL(:) = 0.0; HR(:) = 0.0
                end if
#if (NSPECIES+NMASS_SCALARS) > 0
                do ispu = SPECIES_BEGIN, MASS_SCALARS_END
                   isph= ispu-NPROP_VARS
                   FL(HY_END_FLUX+isph) = xflux(HY_END_FLUX+isph,i,  j,   k   )
                   FR(HY_END_FLUX+isph) = xflux(HY_END_FLUX+isph,i+1,j,   k   )
                   if (NDIM .GE. 2) then
                      GL(HY_END_FLUX+isph) = yflux(HY_END_FLUX+isph,i,  j,   k   )*ky
                      GR(HY_END_FLUX+isph) = yflux(HY_END_FLUX+isph,i,  j+ky,k   )*ky
                   end if
                   if (NDIM == 3) then
                      HL(HY_END_FLUX+isph) = zflux(HY_END_FLUX+isph,i,  j,   k   )*kz
                      HR(HY_END_FLUX+isph) = zflux(HY_END_FLUX+isph,i,  j,   k+kz)*kz
                   end if
                enddo
#endif

                Sphys = 0.0
                Sphys(HY_XMOM)                  = (FL(HY_P_FLUX) - FR(HY_P_FLUX)) *(1.0-fP)/ dx

                if (hy_geometry /= CARTESIAN) then
                   select case(hy_geometry) ! First, select whether y or z is phi-direction
                   case(CYLINDRICAL)
                      MOM_PHI = HY_ZMOM
                      MOM_PHI_FLUX = HY_ZMOM_FLUX
                      velPhiVar    = VELZ_VAR
                      MOM_ZI       = HY_YMOM
                      MOM_ZI_FLUX  = HY_YMOM_FLUX
#if defined(FLASH_USM_MHD) || defined(FLASH_UGLM_MHD)
                      MAG_PHI      = HY_MAGZ
                      MAG_PHI_FLUX = HY_MAGZ_FLUX
                      MAG_ZI       = HY_MAGY
                      MAG_ZI_FLUX  = HY_MAGY_FLUX
#endif
                      dz = xCenter(i) * del(DIR_Z)
                      alpha = 1.

                   case(POLAR)
                      MOM_PHI      = HY_YMOM
                      MOM_PHI_FLUX = HY_YMOM_FLUX
                      velPhiVar    = VELY_VAR
                      MOM_ZI       = HY_ZMOM
                      MOM_ZI_FLUX  = HY_ZMOM_FLUX
#if defined(FLASH_USM_MHD) || defined(FLASH_UGLM_MHD)
                      MAG_PHI      = HY_MAGY
                      MAG_PHI_FLUX = HY_MAGY_FLUX
                      MAG_ZI       = HY_MAGZ
                      MAG_ZI_FLUX  = HY_MAGZ_FLUX
#endif
                      dy = xCenter(i) * del(DIR_Y)
                      alpha = 1.

                   case(SPHERICAL)
                      MOM_PHI      = HY_ZMOM
                      MOM_PHI_FLUX = HY_ZMOM_FLUX
                      velPhiVar    = VELZ_VAR
                      MOM_THT      = HY_YMOM
                      MOM_THT_FLUX = HY_YMOM_FLUX

                      dx_sph = (xRight(i)**3 - xLeft(i)**3) / (3.*xCenter(i)**2)
                      dy     = xCenter(i) * del(DIR_Y)
                      if (NDIM == 3) dz     = xCenter(i) * del(DIR_Z) * sin(yCenter(j))
                      alpha  = 2.
                   end select

#ifdef DEBUG_UHD
!!$     print*,'_unsplitUpdate top: associated(Uin ) is',associated(Uin )
!!$     print*,'_unsplitUpdate top: associated(Uout) is',associated(Uout)
     print*,'_unsplitUpdate top: lbound(Uin ):',lbound(Uin )
     print*,'_unsplitUpdate top: ubound(Uin ):',ubound(Uin )
     print*,'_unsplitUpdate top: lbound(Uout):',lbound(Uout)
     print*,'_unsplitUpdate top: ubound(Uout):',ubound(Uout)
     print*,'_unsplitUpdate top: lbound(faceAreas):',lbound(faceAreas)
     print*,'_unsplitUpdate top: ubound(faceAreas):',ubound(faceAreas)
     print*,'_unsplitUpdate top: lbound(cellVolumes):',lbound(cellVolumes)
     print*,'_unsplitUpdate top: ubound(cellVolumes):',ubound(cellVolumes)
     print*,'_unsplitUpdate top: i,j,k,cellVolumes(i,j,k)=',i,j,k,cellVolumes(i,j,k)
#endif
                   leftFac = faceAreas(i  ,j,k)*dx/cellVolumes(i,j,k)
                   rghtFac = faceAreas(i+1,j,k)*dx/cellVolumes(i,j,k)


                   if (hy_geometry == CYLINDRICAL) then
#ifndef FLASH_USM_MHD
                      FR = FR*faceAreas(i+1,j,k)
                      FL = FL*faceAreas(i  ,j,k)
                      dxv = cellVolumes(i,j,k)
#endif

#ifdef FLASH_USM_MHD                 
                      FR(HY_DENS_FLUX:HY_MAGY_FLUX) = FR(HY_DENS_FLUX:HY_MAGY_FLUX)*rghtFac
                      FL(HY_DENS_FLUX:HY_MAGY_FLUX) = FL(HY_DENS_FLUX:HY_MAGY_FLUX)*leftFac
                    !!skip MAGZ flux will be treated after this
                      FR(HY_EINT_FLUX:HY_VOLU_FLUX) = FR(HY_EINT_FLUX:HY_VOLU_FLUX)*rghtFac
                      FL(HY_EINT_FLUX:HY_VOLU_FLUX) = FL(HY_EINT_FLUX:HY_VOLU_FLUX)*leftFac
#  if (NSPECIES+NMASS_SCALARS) > 0
                      if (hy_fullSpecMsFluxHandling) then
                         do ispu = SPECIES_BEGIN, MASS_SCALARS_END
                            isph= ispu-NPROP_VARS
                            FR(HY_END_FLUX+isph) = FR(HY_END_FLUX+isph)*rghtFac
                            FL(HY_END_FLUX+isph) = FL(HY_END_FLUX+isph)*leftFac
                         enddo
                      end if
#  endif
#endif

                      !! Angular momentum conservative form
                      if (hy_conserveAngMom) then
                         FR(MOM_PHI_FLUX) = FR(MOM_PHI_FLUX)*rghtFac
                         FL(MOM_PHI_FLUX) = FL(MOM_PHI_FLUX)*leftFac
                      endif


                      !! Angular field conservative form
                      !! This is used when the flag is on.
                      !! This formalism does not require the
                      !! source term in the induction equation
                      !! of Bphi, i.e. Sgeo(MAG_PHI) = 0
#ifdef FLASH_USM_MHD
                      if (.not. hy_conserveAngField) then
                         FR(MAG_PHI_FLUX) = FR(MAG_PHI_FLUX)*rghtFac
                         FL(MAG_PHI_FLUX) = FL(MAG_PHI_FLUX)*leftFac
                      endif
#endif
                   else         ! for SPHERICAL or POLAR geometry
                      FR = FR*faceAreas(i+1,j,k)
                      FL = FL*faceAreas(i  ,j,k)
                      dxv = cellVolumes(i,j,k)
                   endif

                endif !end of non-Cartesian support

                if (NDIM .GE. 2) Sphys(HY_YMOM) = (GL(HY_P_FLUX) - GR(HY_P_FLUX)) *(1.0-fP)/ dy
                if (NDIM .EQ. 3) Sphys(HY_ZMOM) = (HL(HY_P_FLUX) - HR(HY_P_FLUX)) *(1.0-fP)/ dz

#if NDIM > 1
                if (hy_geometry == SPHERICAL) then
                   GR = GR*faceAreasY(i,j+1,k)
                   GL = GL*faceAreasY(i,j  ,k)
                   dyv = cellVolumes(i,j,k)
                else
                   dyv = dy
                end if
#endif

                U0(HY_DENS) = Uin(DENS_VAR,i,j,k)                                      !density
                if (hy_geometry /= CARTESIAN) then
#ifdef HALFTIME_DENS_FOR_SGEO_TERMS_AS_IN_SPLIT_HYDRO
                   call updateConservedDens&
                     (U0(HY_DENS),densNew,&
                      FL(HY_DENS_FLUX),&
                      FR(HY_DENS_FLUX),&
                      GL(HY_DENS_FLUX),&
                      GR(HY_DENS_FLUX),&
                      HL(HY_DENS_FLUX),&
                      HR(HY_DENS_FLUX),&
                      dxv,dyv,dz,dt)
                   densNph = 0.5 * (U0(HY_DENS) + densNew) ! average of old and new dens
#else
                   densNph = U0(HY_DENS)
#endif
                end if

                !! radially-averaged pressure at n+1/2 (via characteristic tracing, NOT Riemann solver)
                presStar =  scrch_Ptr(HY_VAR2_SCRATCHCTR_VAR,i,j,k)

                Qohm = 0.0
              
#ifdef FLASH_USM_MHD
                if (hy_useMagneticResistivity) then 
                   speciesArr => Uin(SPECIES_BEGIN:SPECIES_END,i,j,k)
                   call MagneticResistivity(Uin(TEMP_VAR,i,j,k),Uin(DENS_VAR,i,j,k),&
                        speciesArr,res_eta(i,j,k))
                   call hy_addOhmicHeating(tileDesc,blkLimits,i,j,k,Qohm,res_eta(i,j,k))
                   Qohm = Qohm*Uin(DENS_VAR,i,j,k)
                endif
#endif


                if (hy_useAuxEintEqn) then
                   !! Update intenal energy rho*eint
                   IntEner  = Uin(DENS_VAR,i,j,k)*Uin(EINT_VAR,i,j,k)
                   !! Note: scrch_Ptr(HY_VAR1_SCRATCHCTR_VAR,i,j,k) holds the volume-averaged pressures at n+1/2
                   tempPres = scrch_Ptr(HY_VAR1_SCRATCHCTR_VAR,i,j,k)

                   call updateInternalEnergy&
                        (IntEner,tempPres,&
                         FL(HY_EINT_FLUX:HY_VOLU_FLUX),&
                         FR(HY_EINT_FLUX:HY_VOLU_FLUX),&
                         GL(HY_EINT_FLUX:HY_VOLU_FLUX),&
                         GR(HY_EINT_FLUX:HY_VOLU_FLUX),&
                         HL(HY_EINT_FLUX:HY_VOLU_FLUX),&
                         HR(HY_EINT_FLUX:HY_VOLU_FLUX),&
                         dxv,dyv,dz,dt,Qohm)
                endif

#ifdef FLASH_UHD_3T
                !! STORE THE OLD DENSITY AND INTERNAL ENERGY FOR 3T UPDATE
                scrch_Ptr(HY_VAR1_SCRATCHCTR_VAR,i,j,k) = Uin(DENS_VAR,i,j,k)
                scrch_Ptr(HY_VAR2_SCRATCHCTR_VAR,i,j,k) = Uin(EINT_VAR,i,j,k)

#ifdef FLASH_USM_MHD
                scrch_Ptr(HY_XN06_SCRATCHCTR_VAR,i,j,k) = Qohm*dt

                if (hy_hallVelocity) then 
                   !define abar zbar, we store these in scratch for 3T MHD update later on
                   call Eos_getAbarZbar(solnVec=Uin(:,i,j,k),abar=abar,zbar=zbar) 
                   scrch_Ptr(HY_XN04_SCRATCHCTR_VAR,i,j,k) = abar
                   scrch_Ptr(HY_XN05_SCRATCHCTR_VAR,i,j,k) = zbar

                   ! correct the energy fluxes with current terms
                   !! Note: hy_getCurrent sets Jp and Jm for many cells, unless called with mode_switch=4.
                   call hy_getCurrents(tileDesc, rangeSwitch, blkLimits,datasize, del, Jp, Jm, 4,&
                                           scrch_Ptr,&
                                           i, j, k)
                   Sphys(HY_ENER) = ( Jp(1,i,j,k) - Jm(1,i,j,k) ) / dx
                   if (NDIM > 1) then
                      Sphys(HY_ENER) = Sphys(HY_ENER) + ( Jp(2,i,j,k) - Jm(2,i,j,k) ) / dy
                      if (NDIM == 3) then 
                         HL(HY_ENER_FLUX) = HL(HY_ENER_FLUX) - Jm(3,i,j,k)
                         HR(HY_ENER_FLUX) = HR(HY_ENER_FLUX) - Jp(3,i,j,k)
                      endif
                   endif
                endif
#endif
#endif

                !! Prepare to update conserved quantities
                U0(HY_XMOM:HY_ZMOM) = Uin(VELX_VAR:VELZ_VAR,i,j,k)*Uin(DENS_VAR,i,j,k)   !momenta
                U0(HY_ENER) = Uin(DENS_VAR,i,j,k)*Uin(ENER_VAR,i,j,k)                    !total gas energy 
#if defined(FLASH_USM_MHD) || defined(FLASH_UGLM_MHD)
                U0(HY_MAGX:HY_MAGZ) = Uin(MAGX_VAR:MAGZ_VAR,i,j,k)                     !magnetic fields
                U0(HY_ENER) = U0(HY_ENER)+0.5*dot_product(Uin(MAGX_VAR:MAGZ_VAR,i,j,k),&
                                                          Uin(MAGX_VAR:MAGZ_VAR,i,j,k))!total plasma energy
#endif
#ifdef FLASH_UGLM_MHD
                U0(HY_GLMP) = Uin(GLMP_VAR,i,j,k)
#endif

                Sgeo = 0.
                if (hy_geometry /= CARTESIAN) then
                   !! Calculate geometrical source terms.  See S&O 75.
                   !! Advance density and phi-momentum to n+1/2 via finite volume update        
                   densStar = U0(HY_DENS)
                   xvel0    = Uin(VELX_VAR ,i,j,k)
                   phiVel0  = Uin(velPhiVar,i,j,k)
                   xmomStar = U0(HY_XMOM)
                   pmomStar = U0(MOM_PHI)

#if defined(FLASH_USM_MHD) || defined(FLASH_UGLM_MHD)
                   xmagStar = U0(HY_MAGX)
                   pmagStar = U0(MAG_PHI)
                   zmagStar = U0(MAG_ZI)
#endif 
                   cs = sqrt(Uin(GAMC_VAR,i,j,k)*Uin(PRES_VAR,i,j,k)/Uin(DENS_VAR,i,j,k))
                   eta = (abs(Uin(VELX_VAR,i,j,k)) + cs) * dt/dx
                   eta = (1.-eta) / (cs*dt*abs(alpha/xCenter(i)))

                   Sgeo(HY_XMOM) = (densNph*phiVel0*phiVel0 + fP*alpha*presStar) / xCenter(i)!T phi,phi
                   Sgeo(MOM_PHI) = (densNph*phiVel0*xvel0) / xCenter(i)!T phi,r

                   !! take out the source term for conservative form
                   if (hy_geometry == CYLINDRICAL .and. hy_conserveAngMom) then
                      Sgeo(MOM_PHI) = 0.0
                   endif


#if defined(FLASH_USM_MHD) || defined(FLASH_UGLM_MHD)
                 ! P* is the total Pressure
                   Sgeo(HY_XMOM) = Sgeo(HY_XMOM) - (pmagStar**2) / xCenter(i)
                   Sgeo(MOM_PHI) = Sgeo(MOM_PHI) - pmagStar*xmagStar / xCenter(i)

                   if (hy_geometry == CYLINDRICAL .and. hy_conserveAngMom) then
                      Sgeo(MOM_PHI) = 0.0
                   endif

                   Sgeo(MAG_PHI) = - (phiVel0 * xmagStar - &
                                     pmagStar * xvel0) / xCenter(i) !O phi,r

                   if (hy_geometry == CYLINDRICAL .and. &
                       hy_conserveAngField) then
                     
                      Sgeo(MAG_PHI) = 0.0 !!- ((pmomStar/densStar) * xmagStar - &
                                   !!pmagStar * (xmomStar/densStar)) / xCenter(i) +&
                                   !!(FR(MAG_PHI_FLUX)-FL(MAG_PHI_FLUX))/dx -&
                                   !!(FR(MAG_PHI_FLUX)*((xCenter(i)+0.5*dx)/xCenter(i))-&
                                   !!FL(MAG_PHI_FLUX)*((xCenter(i)-0.5*dx)/xCenter(i)))/dx
                                   !! !if (rghtFac>0.0 .and. leftFac==0.0) print*,Sgeo(MAG_PHI)
                   endif
                   if (hy_geometry == CYLINDRICAL .and. &
                       hy_useMagneticResistivity) then
                   
                      if (.not. hy_conserveAngField) then
                         Sgeo(MAG_PHI) = Sgeo(MAG_PHI) + res_source(i,j,k) 
                      endif
                   endif
#endif
                   Sgeo(MOM_PHI) = - Sgeo(MOM_PHI)


                   if (hy_geometry == SPHERICAL) then
!!$                      tmomStar = U0(MOM_THT) 
                      thtVel0  = Uin(VELY_VAR,i,j,k)
                      Sgeo(HY_XMOM) = Sgeo(HY_XMOM) + densNph*thtVel0*thtVel0 / xCenter(i)
                      Sgeo(HY_XMOM) = Sgeo(HY_XMOM)*dx/dx_sph
#if NDIM > 1
                      Sgeo(MOM_THT) = (densNph*phiVel0*phiVel0 + fP*presStar) / xCenter(i)
                      Sgeo(MOM_THT) = Sgeo(MOM_THT) * cos(yCenter(j))/sin(yCenter(j))
                      Sgeo(MOM_THT) = Sgeo(MOM_THT) - (densNph*thtVel0*xvel0) / xCenter(i)
                      Sgeo(MOM_THT) = Sgeo(MOM_THT)*dx/dx_sph
#endif
                   endif
                endif

                !! Now really update conserved quantities
                call updateConservedVariable&
                     (U0(HY_DENS:HY_DENS+HY_VARINUM-1),&
                      FL(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1),&
                      FR(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1),&
                      GL(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1),&
                      GR(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1),&
                      HL(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1),&
                      HR(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1),&
                      gravX(i,j,k),gravY(i,j,k),gravZ(i,j,k),dxv,dyv,dz,dt,Sgeo,Sphys)

#ifdef DEBUG_HYDRO_POSITIVITY
                if (U0(HY_DENS)<hy_smalldens) then
                   print*,'Low DENS',Uin(DENS_VAR,i,j,k),'->',U0(HY_DENS),',X=',xCenter(i),',i,j=',i,j,&
                            ' in Block',block,'@',hy_meshMe
                end if
#endif


                Uout(DENS_VAR,i,j,k) = max(U0(HY_DENS),hy_smalldens)                    !density
#if defined(FLASH_USM_MHD) || defined(FLASH_UGLM_MHD)
                Uout(MAGX_VAR:MAGZ_VAR,i,j,k) = U0(HY_MAGX:HY_MAGZ)                     !magnetic fields
#endif
#ifdef FLASH_UGLM_MHD
                Uout(GLMP_VAR,i,j,k) = U0(HY_GLMP)
#endif
#ifdef DEBUG_HYDRO_POSITIVITY
                if (U0(HY_ENER)/Uout(DENS_VAR,i,j,k)<hy_smallE) then
                   print*,'Low ENER',Uout(ENER_VAR,i,j,k),'->',U0(HY_ENER)/Uout(DENS_VAR,i,j,k),',X=',xCenter(i),',i,j=',i,j,&
                            ' in Block',block,'@',hy_meshMe
                end if
#endif
                Uout(ENER_VAR,i,j,k) = U0(HY_ENER)                                      !total plasma energy
                !! We will update velocity fields after species & mass scalar update

#if (NSPECIES+NMASS_SCALARS) > 0
                newDens = Uout(DENS_VAR,i,j,k)
                if (hy_fullSpecMsFluxHandling) then
                   if (rangeSwitch==UPDATE_ALL_SPECMS_BOUND) then
                      specialForInterior = (i > ibMin .and. i < ibMax)
                      if (NDIM > 1) specialForInterior = specialForInterior .AND. (j > jbMin .and. j < jbMax)
                      if (NDIM > 2) specialForInterior = specialForInterior .AND. (k > kbMin .and. k < kbMax)
                   else
                      specialForInterior = .FALSE.
                   end if
                   sumSpecies = 0.
                   do ispu = SPECIES_BEGIN, MASS_SCALARS_END
                      if (specialForInterior) then
                         Uout(ispu,i,j,k) = Uin(ispu,i,j,k) / newDens
                      else
                         isph= ispu-NPROP_VARS
                         call updateSpeciesMassScalar&
                                 (Uout(ispu,i,j,k),Uold(HY_DENS,i,j,k),newDens,&
                                 FL(HY_END_FLUX+isph),FR(HY_END_FLUX+isph),&
                                 GL(HY_END_FLUX+isph),GR(HY_END_FLUX+isph),&
                                 HL(HY_END_FLUX+isph),HR(HY_END_FLUX+isph),&
                                 dxv,dyv,dz,dt)
                      end if

                      !! Conserving mass fractions
                      if (ispu <= SPECIES_END) then
                         sumSpecies = sumSpecies + Uout(ispu,i,j,k)
                      endif

                   enddo

                !! Conserving mass fractions: They will add up to 1 after this.
                   do ispu = SPECIES_BEGIN, SPECIES_END
                      Uout(ispu,i,j,k) = Uout(ispu,i,j,k)/sumSpecies
                   enddo
                else
                !! Note that the velocity fields here are old velocities at time step n, not n+1
                   call hy_updateSpeciesMassScalar&
                     (hy_order,newDens,&
                      SpOld(1:hy_numXN,i-3:i+3,j-3*ky:j+3*ky,k-3*kz:k+3*kz),&
                      Uold(1:6,        i-3:i+3,j-3*ky:j+3*ky,k-3*kz:k+3*kz),&
                      FL(HY_DENS_FLUX),FR(HY_DENS_FLUX),&
                      GL(HY_DENS_FLUX),GR(HY_DENS_FLUX),&
                      HL(HY_DENS_FLUX),HR(HY_DENS_FLUX),&
                      dxv,dyv,dz,dt, Uout(SPECIES_BEGIN:MASS_SCALARS_END,i,j,k))
                end if
#endif /*if (NSPECIES+NMASS_SCALARS) > 0*/

                !! Update velocity fields after species & mass scalar update
                !! DL - why should it be AFTER??? Ah... ok, in the old way, 
                !!      it still uses velocity fields for mass scalar and species update
                Uout(VELX_VAR:VELZ_VAR,i,j,k) = U0(HY_XMOM:HY_ZMOM)/Uout(DENS_VAR,i,j,k)        !velocities

                Uout(ENER_VAR,i,j,k) = U0(HY_ENER)/Uout(DENS_VAR,i,j,k) !total plasma energy, now in mass-specific form

                if (hy_useAuxEintEqn) then
                   IntEner = IntEner / Uout(DENS_VAR,i,j,k)
#ifdef EINT_VAR
#ifdef DEBUG_HYDRO_POSITIVITY
                   if (IntEner<hy_smallE) then
                      print*,'Low EINT',Uout(EINT_VAR,i,j,k),'->',IntEner,',X=',xCenter(i),',i,j=',i,j,&
                           ' in Block',block,'@',hy_meshMe
                   end if
#endif
                   Uout(EINT_VAR,i,j,k) = IntEner
#endif
                end if

#ifdef FLASH_UHD_3T
#ifdef FLASH_UHD_HYDRO
                !! Perform energy updates here for 3T.  For 1T energy is updated in hy_energyFix.
                !! We only perform the energy updates here for pure hydro only.
                !! MHD still needs to update magnetic fields after the current cell-centered
                !! variable updates. Therefore, the energy updates should be done after
                !! updating magnetic fields.
                ekin = .5*dot_product(Uout(VELX_VAR:VELZ_VAR,i,j,k),Uout(VELX_VAR:VELZ_VAR,i,j,k))

                eint = Uout(ENER_VAR,i,j,k)-ekin

                if (.not. hy_useAuxEintEqn .or. eint > hy_eswitch*ekin) then
                   newEint = max(hy_smallE,eint)
                else
                   newEint = max(hy_smallE,IntEner)
                endif
                !! Store specific gas energy ener = ekin + eint
                Uout(ENER_VAR,i,j,k) = newEint + ekin
#ifdef EINT_VAR
                Uout(EINT_VAR,i,j,k) = newEint
#endif
#endif /*ifdef FLASH_UHD_HYDRO*/
#endif /*ifdef FLASH_UHD_3T*/

#ifdef BDRY_VAR
             endif
#endif

          enddo !end of i loop
       enddo !end of j loop
    enddo !end of k loop

    !! ---------------------------------------------------------------
#if defined(FLASH_USM_MHD) || defined(FLASH_UGLM_MHD)
    ! Set with explicit do loops over appropriate tile-based region
    call Driver_abort("[hy_unsplitUpdate] Update this to work with tiles")
    if (hy_forceHydroLimit) then
       Uout(MAGX_VAR:MAGZ_VAR,:,:,:) = 0.
    endif
#endif

#if (NSPECIES+NMASS_SCALARS) > 0
  ! Renormalize or limit abundances
    if (hy_irenorm == 1) then
       call Grid_renormAbundance(tileDesc,blkLimits,Uout)
    else
       call Grid_limitAbundance(blkLimits,Uout)
    endif
#endif  
!!$
!!$    ! Release block pointers
!!$    call Grid_releaseBlkPtr(blockDesc,U,CENTER)



  CONTAINS

    !  The rangeSwitch==UPDATE_SPECMS_INTERIOR case is farmed out to this simpler routine.
    subroutine unsplitUpdateSpecMs

#if (NSPECIES+NMASS_SCALARS) > 0


      dx = del(DIR_X)
      dy = 1.
      dz = 1.
      if (NDIM >= 2) then
         dy = del(DIR_Y)
         if (NDIM == 3) then
            dz = del(DIR_Z)
         endif
      endif
      dxv = dx; dyv = dy

    !! Set region to update for update mode UPDATE_SPECMS_INTERIOR
      imin  = max(blkLimits(LOW, IAXIS),ibMin+1)
      imax  = min(blkLimits(HIGH,IAXIS),ibMax-1)
      if (NDIM >= 2) then
         jmin  = max(blkLimits(LOW, JAXIS),jbMin+1)
         jmax  = min(blkLimits(HIGH,JAXIS),jbMax-1)
         if (NDIM == 3) then
            kmin  = max(blkLimits(LOW, KAXIS),kbMin+1)
            kmax  = min(blkLimits(HIGH,KAXIS),kbMax-1)
         else
            kmin  = 1
            kmax  = 1
         endif
      else
         jmin  = 1
         jmax  = 1
      endif


    if (hy_geometry /= CARTESIAN) then
       call Grid_getCellFaceAreas(IAXIS, tileDesc%level, &
                                  lbound(faceAreas), ubound(faceAreas), &
                                  faceAreas)
#if NDIM > 1
    ! DEV: FIXME Include this again and see if we can use faceAreas and
    !            cellVolumes instead
       if (hy_geometry == SPHERICAL) then
          call Grid_getCellFaceAreas(JAXIS, tileDesc%level, &
                                     lbound(faceAreasY), ubound(faceAreasY), &
                                     faceAreasY)
       end if
#endif

       call Grid_getCellVolumes(tileDesc%level, &
                                lbound(cellVolumes), ubound(cellVolumes), &
                                cellVolumes)
    endif

    

    if (.NOT. hy_fullSpecMsFluxHandling) then
       ! Set these with explicit loop nests over a tile-based region
       call Driver_abort("[hy_unsplitUpdate] Update these to work with tiles")
       do ispu =  SPECIES_BEGIN, MASS_SCALARS_END
          isph= ispu-NPROP_VARS
          SpOld(isph,:,:,:) = Uout(ispu,:,:,:)
       enddo
       Uold(1,  :,:,:) = Uin(DENS_VAR,:,:,:)
       Uold(2,  :,:,:) = Uin(PRES_VAR,:,:,:)
       Uold(3:5,:,:,:) = Uin(VELX_VAR:VELZ_VAR,:,:,:)
       Uold(6,  :,:,:) = Uin(GAME_VAR,:,:,:)
    end if

    if (hy_geometry /= CARTESIAN) then
       call Grid_getCellCoords(IAXIS, CENTER, tileDesc%level, &
                               blGC(LOW, :), blGC(HIGH, :), xCenter)
       call Grid_getCellCoords(IAXIS, LEFT_EDGE, tileDesc%level, &
                               blGC(LOW, :), blGC(HIGH, :), xLeft)
       call Grid_getCellCoords(IAXIS, RIGHT_EDGE, tileDesc%level, &
                               blGC(LOW, :), blGC(HIGH, :), xRight)
       if (NDIM == 3 .AND. hy_geometry == SPHERICAL) then
          call Driver_abort("[hy_unsplitUpdate] This has not been tested")
          call Grid_getCellCoords(JAXIS, CENTER, tileDesc%level, &
                                  blkLimits(LOW, :), blkLimits(HIGH, :), &
                                  yCenter)
       end if
    endif


    do k=kmin,kmax
       do j=jmin,jmax
          do i=imin,imax
#ifdef BDRY_VAR
             if (Uout(BDRY_VAR,i,j,k) .LE. 0.0) then
#endif
                !! For non-cartesian geometries
                leftFac = 1.
                rghtFac = 1.

                !! Fluxes at each local cell 
                do ispu = SPECIES_BEGIN, MASS_SCALARS_END
                   isph= ispu-NPROP_VARS
                   FL(HY_END_FLUX+isph) = xflux(HY_END_FLUX+isph,i,  j,   k   )
                   FR(HY_END_FLUX+isph) = xflux(HY_END_FLUX+isph,i+1,j,   k   )
#if NDIM >= 2
                   GL(HY_END_FLUX+isph) = yflux(HY_END_FLUX+isph,i,  j,   k   )*ky
                   GR(HY_END_FLUX+isph) = yflux(HY_END_FLUX+isph,i,  j+ky,k   )*ky
#else
                   GL(:) = 0.0; GR(:) = 0.0
#endif
#if NDIM == 3
                   HL(HY_END_FLUX+isph) = zflux(HY_END_FLUX+isph,i,  j,   k   )*kz
                   HR(HY_END_FLUX+isph) = zflux(HY_END_FLUX+isph,i,  j,   k+kz)*kz
#else
                   HL(:) = 0.0; HR(:) = 0.0
#endif
                enddo



                if (hy_geometry /= CARTESIAN) then
                   if (NDIM > 1) then
                      select case(hy_geometry) ! First, select whether y or z is phi-direction
                      case(CYLINDRICAL)
                         if (NDIM == 3) dz = xCenter(i) * del(DIR_Z)

                      case(POLAR)
                         dy = xCenter(i) * del(DIR_Y)

                      case(SPHERICAL)
                         dy     = xCenter(i) * del(DIR_Y)
                         if (NDIM == 3) dz     = xCenter(i) * del(DIR_Z) * sin(yCenter(j))
                      end select
                   end if

                   leftFac = faceAreas(i  ,j,k)
                   rghtFac = faceAreas(i+1,j,k)
                   dxv = cellVolumes(i,j,k)

                   if (hy_fullSpecMsFluxHandling) then
                      do ispu = SPECIES_BEGIN, MASS_SCALARS_END
                         isph= ispu-NPROP_VARS
                         FR(HY_END_FLUX+isph) = FR(HY_END_FLUX+isph)*rghtFac
                         FL(HY_END_FLUX+isph) = FL(HY_END_FLUX+isph)*leftFac
                      enddo
                   else
                      FR(HY_DENS_FLUX) = FR(HY_DENS_FLUX)*rghtFac
                      FL(HY_DENS_FLUX) = FL(HY_DENS_FLUX)*leftFac
                   end if

                   dyv = dy
#if NDIM > 1
                   if (hy_geometry == SPHERICAL) then
                      leftFac = faceAreasY(i,j  ,k)
                      rghtFac = faceAreasY(i,j+1,k)
                      dyv = cellVolumes(i,j,k)

                      if (hy_fullSpecMsFluxHandling) then
                         do ispu = SPECIES_BEGIN, MASS_SCALARS_END
                            isph= ispu-NPROP_VARS
                            GR(HY_END_FLUX+isph) = GR(HY_END_FLUX+isph)*rghtFac
                            GL(HY_END_FLUX+isph) = GL(HY_END_FLUX+isph)*leftFac
                         enddo
                      else
                         GR(HY_DENS_FLUX) = GR(HY_DENS_FLUX)*rghtFac
                         GL(HY_DENS_FLUX) = GL(HY_DENS_FLUX)*leftFac
                      end if
                   end if
#endif

                endif !end of non-Cartesian support


                if (hy_fullSpecMsFluxHandling) then
                   do ispu = SPECIES_BEGIN, MASS_SCALARS_END
                      isph= ispu-NPROP_VARS
                      call updateSpeciesMassScalar&
                                 (Uout(ispu,i,j,k),Uout(DENS_VAR,i,j,k), 1.0,&
                                 FL(HY_END_FLUX+isph),FR(HY_END_FLUX+isph),&
                                 GL(HY_END_FLUX+isph),GR(HY_END_FLUX+isph),&
                                 HL(HY_END_FLUX+isph),HR(HY_END_FLUX+isph),&
                                 dxv,dyv,dz,dt)
                   enddo

                else
                !! Note that the velocity fields here are old velocities at time step n, not n+1
                   call hy_updateSpeciesMassScalar&
                     (hy_order,0.0,&
                      SpOld(1:hy_numXN,i-3:i+3,j-3*ky:j+3*ky,k-3*kz:k+3*kz),&
                      Uold(1:6,        i-3:i+3,j-3*ky:j+3*ky,k-3*kz:k+3*kz),&
                      FL(HY_DENS_FLUX),FR(HY_DENS_FLUX),&
                      GL(HY_DENS_FLUX),GR(HY_DENS_FLUX),&
                      HL(HY_DENS_FLUX),HR(HY_DENS_FLUX),&
                      dxv,dyv,dz,dt, Uout(SPECIES_BEGIN:MASS_SCALARS_END,i,j,k))
                end if


#ifdef BDRY_VAR
             endif
#endif

          enddo !end of i loop
       enddo !end of j loop
    enddo !end of k loop

    !! ---------------------------------------------------------------
!!$    ! Release block pointers
!!$    call Grid_releaseBlkPtr(blockDesc,U,CENTER)
#endif

  End Subroutine unsplitUpdateSpecMs







  End Subroutine hy_unsplitUpdate



!! ==================================================================
Subroutine updateConservedVariable(Ul,FL,FR,GL,GR,HL,HR,  &
                                      gravX, gravY, gravZ,&
                                      dx,dy,dz,dt,Sgeo,Sphys)
  use Hydro_data, ONLY : hy_useGravity
  implicit none
  real, dimension(HY_VARINUM), intent(INOUT) :: Ul
  real, dimension(HY_VARINUM), intent(IN) :: Sgeo,Sphys
  real, dimension(HY_VARINUM), intent(IN) :: FL,FR,GL,GR,HL,HR
  real, intent(IN) :: gravX,gravY,gravZ
  real, intent(IN) :: dx,dy,dz,dt
  real, dimension(3) :: momentaOld
  real :: densOld

  !! Store old states at n
  densOld = Ul(HY_DENS)
  momentaOld(1:3) = Ul(HY_XMOM:HY_ZMOM)

  !! Update conservative variables from n to n+1 step
  Ul(HY_DENS:HY_DENS+HY_VARINUM-1)=Ul(HY_DENS:HY_DENS+HY_VARINUM-1)&
       -dt/dx*( FR(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1)&
               -FL(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1))
  
  if (NDIM > 1) then
  Ul(HY_DENS:HY_DENS+HY_VARINUM-1)=Ul(HY_DENS:HY_DENS+HY_VARINUM-1)&
       -dt/dy*( GR(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1)&
               -GL(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1))

  if (NDIM > 2) then
  Ul(HY_DENS:HY_DENS+HY_VARINUM-1)=Ul(HY_DENS:HY_DENS+HY_VARINUM-1)& 
       -dt/dz*( HR(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1)&
               -HL(HY_DENS_FLUX:HY_DENS_FLUX+HY_VARINUM-1))
  endif

  endif


  !! Include geometric and physical source terms
  Ul = Ul + dt*(Sgeo+Sphys)

  if (hy_useGravity) then
     !! Note: 1. Extrapolated gravity case
     !!          gravX,Y,Z - gravity at n
     !!------------------------------------------

     !! Update total energy (rho*E) with gravity source
     !! The following is new gravity formulation.  Still needs to be corrected by n+1 gravity!!!
     Ul(HY_XMOM:HY_ZMOM) = Ul(HY_XMOM:HY_ZMOM)&
          + 0.5*dt*densOld*(/gravX,gravY,gravZ/)

     Ul(HY_ENER) = Ul(HY_ENER) &
          + 0.5*dt*dot_product(momentaOld(1:3),(/gravX,gravY,gravZ/))

  endif


End Subroutine updateConservedVariable

!! ==================================================================
Subroutine updateConservedDens(densOld,densOut,FL,FR,GL,GR,HL,HR,  &
                                      dx,dy,dz,dt)
  use Hydro_data, ONLY : hy_useGravity
  implicit none
  real, intent(IN)  :: densOld
  real, intent(OUT) :: densOut
  real, intent(IN) :: FL,FR,GL,GR,HL,HR
  real, intent(IN) :: dx,dy,dz,dt

  real :: densNew

  !! Copy old density at n
  densNew = densOld

  !! Update conservative variables from n to n+1 step
  densNew=densNew&
       -dt/dx*( FR-FL)
  
  if (NDIM > 1) then
     densNew=densNew&
       -dt/dy*( GR-GL)

     if (NDIM > 2) then
        densNew=densNew& 
             -dt/dz*( HR-HL)
     endif

  endif

  densOut = densNew
End Subroutine updateConservedDens


!! ==================================================================
Subroutine updateInternalEnergy(eint,pres,FL,FR,GL,GR,HL,HR,dx,dy,dz,dt,Qohm)

  implicit none

  real, intent(INOUT) :: eint ! (=rho*eint)
  real, dimension(2), intent(IN) :: FL,FR,GL,GR,HL,HR
  real, intent(IN) :: pres,dx,dy,dz,dt,Qohm

  eint = eint + dt/dx*(FL(1)-FR(1) + pres*(FL(2)-FR(2)))

  if (NDIM > 1) then
  eint = eint + dt/dy*(GL(1)-GR(1) + pres*(GL(2)-GR(2)))

  if (NDIM > 2) then
  eint = eint + dt/dz*(HL(1)-HR(1) + pres*(HL(2)-HR(2)))
  endif
  endif
  eint = eint + dt*Qohm 

End Subroutine updateInternalEnergy
!! ==================================================================
Subroutine updateSpeciesMassScalar(Spc,densOld,densNew,FL,FR,GL,GR,HL,HR,dx,dy,dz,dt)

  implicit none

  real, intent(INOUT) :: Spc
  real, intent(IN)    :: densOld,densNew
  real, intent(IN)    :: FL,FR,GL,GR,HL,HR
  real, intent(IN)    :: dx,dy,dz,dt

#if NDIM == 1
  Spc = (Spc*densOld + dt*(FL-FR)/dx)/densNew
#elif NDIM == 2
  Spc = (Spc*densOld + dt*((FL-FR)/dx+(GL-GR)/dy))/densNew
#else
  Spc = (Spc*densOld + dt*((FL-FR)/dx+(GL-GR)/dy+(HL-HR)/dz))/densNew
#endif


End Subroutine updateSpeciesMassScalar
!! ==================================================================
